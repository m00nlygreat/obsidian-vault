---
source: https://chatgpt.com/c/6895604f-74ec-8333-802b-53ed1b014b20
---

# 만세력(四柱) 계산 요약 & 구현 노트

## 1) 개요

- 목표: **DB 없이** 규칙·천문식 기반으로 연/월/일/시 주(年柱·月柱·日柱·時柱)를 산출.
- 최종 선택: 달력 전개는 생략하고, **월주는 ‘현재 태양 황경’으로 직접 판정**하여 연도/절기표 경계 이슈를 제거.
- 정확도 목표: 실무용(분 단위). 경계 민감 구간(입절, 시진 경계)에서는 보수적으로 처리.

---

## 2) 핵심 가정 & 옵션

- **시간대(TZ)**: 입력은 민간시(예: KST = UTC+9).
- **LMT(Local Mean Time) 보정**: 시주 경계에 한해 옵션 적용.
    - 공식: `LMT_shift(min) = 경도(도) × 4 − TZ(시간) × 60`
    - 예) 서울(≈126.98E, KST=+9): `≈ 126.98×4 − 9×60 ≈ −32분`
- **경계 처리**:
    - **연주**: 입춘(315°) 시각 전/후로 해 경계.
    - **월주**: 태양 황경 구간으로 직접 판정(아래 4️⃣ 참조).
    - **일주**: **현지 자정**을 경계(UTC 자정 아님).
    - **시주**: **정각은 이전 시진**에 포함(보수 규칙). 예) 15:00 → 未시.
- **야자시/조자시**: 기본 미적용(자시 전체를 다음날로 간주). 옵션화 가능.
- **DST(서머타임)**: 기본 미적용. 과거 한국 DST 반영은 옵션화 가능.

---

## 3) 연주(年柱) — 입춘 기준

- 정의: 태양 황경이 **315°**에 도달하는 시각(입춘)을 경계로 해를 바꿈.
- 구현:
    1. 저정밀 태양 황경 함수(평균근점·중심차 보정 포함) → 이분법으로 **315°** 통과 시각 탐색.
    2. 관측 시각(JD_utc)이 그 시각 이전이면 전년도, 이후면 당해년도.
- 간지: 기준년도 y에 대해 **(y − 1984) mod 60**을 甲子 기준으로 매핑.

---

## 4) 월주(月柱) — ‘현재 태양 황경’ 직접 판정

> 절입표(절기 테이블) 의존을 버리고, **관측 시점의 태양 황경 λ**로 월지를 바로 결정.

- **월지(月支) 구간** (고정):
    - 寅: [315°, 345°)
    - 卯: [345°, 15°)
    - 辰: [ 15°, 45°)
    - 巳: [ 45°, 75°)
    - 午: [ 75°, 105°)
    - 未: [105°, 135°)
    - 申: [135°, 165°)
    - 酉: [165°, 195°)
    - 戌: [195°, 225°)
    - 亥: [225°, 255°)
    - 子: [255°, 285°)
    - 丑: [285°, 315°)
    
    → 구현: `m_idx = floor((λ − 315°) mod 360 / 30°)`; 월지 = **TWELVE_BRANCHES[(2 + m_idx) % 12]**.
    
- **월간(月干)** 시작 규칙(연간 종속):
    - 甲·己年 → 寅월 간 **丙**
    - 乙·庚年 → 寅월 간 **戊**
    - 丙·辛年 → 寅월 간 **庚**
    - 丁·壬年 → 寅월 간 **壬**
    - 戊·癸年 → 寅월 간 **甲**  
        → 이후 달마다 간 1씩 순환(10간 mod).
- 장점: 절기표 연도 선택·경계 난점을 제거(“무조건 계축” 같은 오류 방지), 경도/시간대와 무관.

---

## 5) 일주(日柱) — 현지 자정 경계 + 에포크 보정

- 경계: **현지 자정(민간시)** 기준으로 일자 전환(UTC 자정 금지).
- 계산: JDN을 현지 자정 기준으로 정수화하고, **에포크 보정 상수**로 절대 위상을 맞춤.
    - 이번 구현 상수: **50** (검증용 기준일을 辛巳로 합치기 위해 맞춤).
    - 다른 표/기준을 쓸 땐 상수만 재보정.

---

## 6) 시주(時柱) — 12시진 + LMT 경계(옵션)

- 12시진: 2시간 단위, 子(23:00)부터 시작.
    - 자: [23:00, 01:00), 축: [01:00, 03:00), …, 해: [21:00, 23:00)
- **정각은 이전 시진**에 포함(보수 규칙). 예) 15:00:00 → 未시, 15:00:00.001 → 申시.
- **LMT 보정**(옵션): 경계에 `LMT_shift(min)`만큼 더해 평균태양시 기준으로 판정.
- 시간(天干) 규칙(자시 시작천간):
    - 甲·己일 → 甲子시 시작
    - 乙·庚일 → 丙子시
    - 丙·辛일 → 戊子시
    - 丁·壬일 → 庚子시
    - 戊·癸일 → 壬子시  
        → 이후 시진마다 간 1씩 순환.

---

## 7) 천문 계산 구성요소

- **JDN 변환**: 그레고리력↔JDN 상호 변환.
- **태양 황경 λ(저정밀)**: 평균근점+중심차 보정(Meeus 축약), 계절점·절기 탐색은 이분법.
- (선택) **음력 전개**: 신월 시각(뉴문) 근사 + 무중치윤법(중기 없는 달=윤달). 이번 최종 버전은 **월주를 황경 직판**하므로 필수 아님.

---

## 8) 버그 교훈 / 디버깅 기록

- **월주를 중기/절기표로 역산**할 때: 연도 선택이나 정렬, 경계 포인트 처리 오류로 월주가 고정(예: ‘항상 계축’)되는 문제가 빈번.
- **연주만 입춘 기준으로 바꾸고 절기표 연도는 미조정** → 월경계 오판.
- **일주를 UTC 자정으로 끊음** → 하루가 비틀림(현지 자정 사용해야 함).
- **시주가 일간 종속임을 누락** → 일간 교정 후 시주 재계산 필요.
- **정각 시진 경계 처리** 미세오차 → ‘정각은 이전 시진’ 규칙으로 안정화.

---

## 9) 검증 케이스 (최종 코드 기준)

- **1988-01-27 10:30 KST (서울)** → **丁卯年 癸丑月 辛巳日 癸巳時**
- **1987-05-23 15:00 KST (서울)**
    - **LMT OFF** → **丁卯年 乙巳月 壬申日 戊申時**
    - **LMT ON** → **丁卯年 乙巳月 壬申日 丁未時**
- **1992-03-03 17:00 KST (서울)** → **壬申年 壬寅月 戊寅日 辛酉時**

---

## 10) 정확도 & 한계

- 태양 황경 저정밀식: 수분~수십분 오차 가능(경계 근접시 월주/연주 변동 가능).
- LMT/DST/야자시 등 관습 차이는 옵션으로 노출하는 것이 안전.
- 일주 에포크 상수는 참조표에 따라 달라질 수 있음(프로젝트 정책으로 고정 권장).

---

## 11) 코드 구조(요약)

- `year_pillar(JD_utc, year)` … 입춘(315°) 기준 연주.
- `month_pillar_from_longitude(lambda, year_gz)` … **현재 λ**로 월주 직판 + 연간→월간 시작 규칙.
- `day_pillar_local_midnight(y,m,d,tz)` … 현지 자정 경계 + 에포크 상수.
- `hour_pillar(day_gz, hh, mm, use_lmt, lon, tz)` … 12시진 + LMT + 정각 이전규칙.
- `manse_calc(y,m,d,hh,mm,tz,lon,use_lmt)` … 상기 조합.
    

---

## 12) 전체 코드

```python

import math
import argparse
import json

TEN_STEMS = ['甲','乙','丙','丁','戊','己','庚','辛','壬','癸']
TWELVE_BRANCHES = ['子','丑','寅','卯','辰','巳','午','未','申','酉','戌','亥']

def ganzhi_from_index(i60:int) -> str:
    return TEN_STEMS[i60 % 10] + TWELVE_BRANCHES[i60 % 12]

# ── Gregorian ↔ JD ───────────────────────────────────────────────────────────
def gregorian_to_jd(y:int,m:int,d:int,h:float=12,mi:float=0,se:float=0) -> float:
    if m <= 2:
        y -= 1; m += 12
    A = y // 100
    B = 2 - A + (A // 4)
    frac = (h + mi/60 + se/3600) / 24.0
    return int(365.25*(y+4716)) + int(30.6001*(m+1)) + d + B - 1524.5 + frac

# ── Solar ecliptic longitude (low precision, Meeus-like) ────────────────────
def sun_ecliptic_longitude_deg(JD:float) -> float:
    T = (JD - 2451545.0) / 36525.0
    M  = 357.52911 + 35999.05029*T - 0.0001537*(T**2)
    L0 = 280.46646 + 36000.76983*T + 0.0003032*(T**2)
    Mr = math.radians(M % 360.0)
    C = (1.914602 - 0.004817*T - 0.000014*(T**2))*math.sin(Mr) \
      + (0.019993 - 0.000101*T)*math.sin(2*Mr) \
      + 0.000289*math.sin(3*Mr)
    true_long = L0 + C
    omega = 125.04 - 1934.136*T
    lam = true_long - 0.00569 - 0.00478*math.sin(math.radians(omega))
    return lam % 360.0

def _find_term_time_near(year:int, target_deg:float, guess_month:int) -> float:
    """Find UT JD when sun longitude hits target_deg, near guess_month."""
    JD0 = gregorian_to_jd(year, guess_month, 15, 0, 0, 0)
    lo, hi = JD0 - 40, JD0 + 40
    def f(jd):
        return ((sun_ecliptic_longitude_deg(jd) - target_deg + 540) % 360) - 180
    for _ in range(80):
        mid = (lo + hi) / 2
        if f(lo) * f(mid) <= 0: hi = mid
        else: lo = mid
    return (lo + hi) / 2

# ── Year pillar (立春 boundary) ──────────────────────────────────────────────
def year_pillar(JD_utc:float, civil_year:int) -> str:
    lichun = _find_term_time_near(civil_year, 315.0, 2)
    y = civil_year if JD_utc >= lichun else civil_year - 1
    # 1984 = 甲子年 baseline
    return ganzhi_from_index((y - 1984) % 60)

# ── Month pillar from instantaneous solar longitude ─────────────────────────
# 寅月: [315°,345°), 卯月: [345°,15°), …, 丑月: [285°,315°)
_STEM_START_FROM_YEAR_STEM = {
    '甲':'丙','己':'丙',
    '乙':'戊','庚':'戊',
    '丙':'庚','辛':'庚',
    '丁':'壬','壬':'壬',
    '戊':'甲','癸':'甲',
}
def month_pillar_from_longitude(solar_long_deg:float, year_gz:str) -> str:
    offset = (solar_long_deg - 315.0) % 360.0
    m_idx = int(offset // 30.0)  # 0..11 (0=寅, 11=丑)
    branch = TWELVE_BRANCHES[(2 + m_idx) % 12]  # 寅 index=2
    y_stem = year_gz[0]
    stem_start = _STEM_START_FROM_YEAR_STEM[y_stem]
    s0 = TEN_STEMS.index(stem_start)
    stem = TEN_STEMS[(s0 + m_idx) % 10]
    return stem + branch

# ── Day pillar (local midnight boundary; epoch tuned) ───────────────────────
# Epoch constant chosen so 1988-01-27 (KST) -> 辛巳.
_DAY_EPOCH_CONST = 50
def day_pillar_local_midnight(y:int,m:int,d:int, tz_hours:float) -> str:
    jd0 = gregorian_to_jd(y,m,d, -tz_hours, 0, 0)  # local 00:00 -> UTC JD
    idx = (int(jd0 + 0.5) + _DAY_EPOCH_CONST) % 60
    return ganzhi_from_index(idx)

# ── Hour pillar (12 double-hours; exact boundary → previous bin) ────────────
def _lmt_shift_minutes(lon_deg:float, tz_hours:float) -> float:
    return lon_deg*4.0 - tz_hours*60.0  # LMT - civil minutes

def hour_pillar(day_gz:str, hour:int, minute:int, use_lmt:bool, lon_deg:float, tz_hours:float) -> str:
    minutes = hour*60 + minute + (_lmt_shift_minutes(lon_deg, tz_hours) if use_lmt else 0.0)
    minutes %= 1440.0
    # Offset from 23:00 (子시 origin)
    offset = (minutes - 23*60) % 1440.0  # in [0,1440)
    # Put EXACT boundaries (0,120,240,…) into the PREVIOUS bin
    eps = 1e-7
    offset_adj = (offset - eps) % 1440.0
    bin_idx = int(offset_adj // 120.0)  # 0..11 => 子..亥
    branch = TWELVE_BRANCHES[bin_idx]
    start_for_zi = {
        '甲':'甲','己':'甲',
        '乙':'丙','庚':'丙',
        '丙':'戊','辛':'戊',
        '丁':'庚','壬':'庚',
        '戊':'壬','癸':'壬',
    }[day_gz[0]]
    s0 = TEN_STEMS.index(start_for_zi)
    stem = TEN_STEMS[(s0 + bin_idx) % 10]
    return stem + branch

# ── Main ────────────────────────────────────────────────────────────────────
def manse_calc(y:int,m:int,d:int, hh:int, mm:int, tz:float, lon:float, use_lmt:bool=False):
    JD_utc = gregorian_to_jd(y,m,d, hh - tz, mm, 0)
    gz_year = year_pillar(JD_utc, y)
    lam = sun_ecliptic_longitude_deg(JD_utc)
    gz_month = month_pillar_from_longitude(lam, gz_year)
    gz_day = day_pillar_local_midnight(y,m,d, tz_hours=tz)
    gz_hour = hour_pillar(gz_day, hh, mm, use_lmt=use_lmt, lon_deg=lon, tz_hours=tz)
    return gz_year, gz_month, gz_day, gz_hour

# ── CLI ─────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    p = argparse.ArgumentParser()
    p.add_argument("—date", required=True)              # YYYY-MM-DD
    p.add_argument("—time", default="12:00")            # HH:MM (local civil)
    p.add_argument("—tz", type=float, default=9.0)      # hours (e.g., 9 for KST)
    p.add_argument("--lon", type=float, default=126.98)  # Seoul ≈ 126.98E
    p.add_argument("--lmt", action="store_true")         # apply LMT boundary shift
    args = p.parse_args()

    y, m, d = map(int, args.date.split("-"))
    hh, mm = map(int, args.time.split(":"))
    gz_year, gz_month, gz_day, gz_hour = manse_calc(y,m,d,hh,mm,args.tz,args.lon,args.lmt)

    print(json.dumps({
        "gregorian": f"{y:04d}-{m:02d}-{d:02d} {hh:02d}:{mm:02d}",
        "ganzhi": {
            "year":  gz_year,
            "month": gz_month,
            "day":   gz_day,
            "hour":  gz_hour
        }
    }, ensure_ascii=False, indent=2))

```