---
title: 무한회귀 바이브코딩
type: text
author: 배문형
tags:
  - 바이브코딩
  - 생성형AI
  - 언어모델
---

# 들어가며

![강사 소개](강사%20소개.md)

## 바이브 코딩(Vibe Coding)

- 캐나다의 인공지능 과학자, **안드레 카파시**(Andrej Kaparthy)가 만든 단어
	- 기존 논리 기반의 규칙이 엄격하고 질서정연한 사고과정을 통해 코드를 작성하던 전통적 개발과 달리, 
	- *느낌(vibe) 위주로 언어모델에게 요청하여 코드를 작성하는 개발방법*
- 비개발자도 자연어로 소프트웨어를 작성할 수 있는 **기술의 민주화** 시대가 도래했다는 의견

#### ...이지만 정말 그럴까?

![](attachments/vibecoding-genie.png)

# 무엇을 만들 것인가

## 기획

### 무엇을 만들지 생각하기

- 부록(소프트웨어의 분류) 참고
- 바이브코딩의 대부분은 웹 애플리케이션 Saas 프로덕트를 작성

### 제품 요구사항 정의서 (Product Requirement Document) 작성

- 바이브코딩에서 **요구사항 정의서는 곧 프롬프트**가 됩니다.

![요구사항 정의서](modules/요구사항%20정의서.md)

## 제품의 복잡도 결정

![](attachments/architecture-complex.png)

---

### 심플하게 가자

- **Standalone**: DB, 프론트/백엔드 통합
	- Ruby on Rails / SQLite
- **Static Web**: 오로지 정해진 내용만 보여주는 웹사이트 (위키피디아 등..)
- **CLI/TUI App**: 터미널에서 실행되는 애플리케이션 (자동화 앱 등)

![](attachments/architecture-simple.png) 

# 무.한.회.귀 바이브코딩

## 바이브코딩 도구

### 풀 바이브

- 코딩, 디자인, [데이터베이스], 배포까지 완전 자동
	- Lovable, Bolt.new, Repl.it, Figma Make, v0.dev

### AI-Assisted Coding

- MCP 등의 도구를 사용해 코드를 자동으로 쓰고, 테스트, 커밋까지 자동화하는 코딩 도구
	- Cursor, Claude-code, Gemini-CLI, OpenAI Codex 등

#### 용어에 대한 논란 있음

- Vibe Engineering, Augmented Coding, AI Pair Programming..

## 프로그램은 하나의 폴더와 여러 개의 텍스트 파일로 이루어져 있다.

### 코드베이스

- 이 구성을 **코드베이스**(Codebase)라 하며, 하나의 프로젝트는 보통 하나의 코드베이스로 이루어져 있음
- *외부 패키지/모듈 설치, Git 저장소, Docker* 등 각종 개발 활동의 단위가 됨
- Claude Code, Gemini-CLI, Cursor 등의 도구는 이 코드베이스를 생성하거나 읽고 관련된 코드를 생성하는 것이 목적
	- ChatGPT와 같은 웹 챗봇 인터페이스에서는 코드를 생성할 수는 있어도, 코드베이스를 기반으로 유의미하게 관련있는 코드를 만들지 못하기 때문

#### 배포(Deploy)

- 코드베이스가 밀키트라면, 이 **밀키트를 조리해서 제공**하는 것이 배포
- 사용자에게 전달할 수 있도록 *앱 마켓에 등록하거나 웹사이트 URL을 마련하는 것*

![](attachments/vibe-codebase.png)

## Git과 Github, 그리고 Branch

- Git 과 Github은 **코드베이스를 버전관리** 하는 도구

### 브랜치

- 코드베이스의 **복제본**
- `main` 브랜치를 중심으로 새 기능을 추가하거나 변경할 때마다 새 브랜치를 만들어 안전하게 작업한 뒤 `main`으로 병합(merge)하는 방식으로 작업
	- 브랜치를 날려도 main에는 영향이 없다!

![](attachments/vibe-git_branching.png)

## 그렇다면!

![](attachments/vibe-aha.png)

## 무.한.회.귀 바이브코딩

- 고전 RPG 게임처럼 실패하면 
	- 과거의 *세이브 포인트로 돌아가* 다시 진행하는 것으로 
	- 결국 엔딩에 도달하는 방식의 바이브 코딩
- 코드를 전혀 몰라도 할 수 있나요?
	- *It's on you!*

> Github의 **Branch 기능**을 적극사용 합니다.

![](attachments/vibe-infinite_loop.png)

## 스킬

### 진행

- `PRD.md`와 `AGENTS.md` 작성하고
- **Github 브랜치**를 생성하여 프롬프트를 던지고 작업 시작

### 전투

- 에러 및 버그 발생시 오류 메시지를 확인하고 고쳐달라 요청하기
- 각 단계에서 *어디서 버그를 확인해야 하는지* 명확히 알기

***

### 세이브

- 원하던 작업과 테스트가 완료되면 **변경사항 커밋** / **브랜치 병합**하여 작업 내용을 저장

### 로드

- 버그를 수정할 수 없거나, 의도대로 결과가 나오지 않는 경우 브랜치를 삭제해서 마지막 안정 상태로 돌아가서 다시 시도하기

> 때에 따라 이미 수행한 *브랜치 병합을 되돌려야* 하는 경우도 있다!

### 최종보스

- **배포(Deploy)**: 사용자에게 프로그램을 전달하는 것

## 코드가 하는 일

- [**Show**]: 화면에 표시
- [**Wait**]: 사용자 입력 대기
  - UI / 입력장치
- [**Calculate**]: 데이터 가공
- [**Write**]: 데이터 기록
  - DB (로컬 / 원격)
- [**Read**]: 데이터 불러오기
	- API, DB, 통신
- [**Call**]: 다른 프로그램 사용하기
  - API, 라이브러리, Extensions, Plugins

> 코드가 하는 작업을 이 6개로 쪼개고 분류해야 한다.

![](attachments/vibe-6_components.png)

# 실습: 터미널 없는 바이브코딩

![터미널 없는 진짜 바이브코딩 워크플로우.tutorial](practices/터미널%20없는%20진짜%20바이브코딩%20워크플로우.tutorial.md)

![AS 안내](AS%20안내.md)

# 부록: 소프트웨어의 분류

![소프트웨어 분류](modules/소프트웨어%20분류.md)

# 부록: 마크다운

![마크다운](modules/마크다운.md)